#[macro_use]
extern crate log;
extern crate pretty_env_logger;
use futures::executor::block_on;
use human_panic::setup_panic;
use r2d2_sqlite::SqliteConnectionManager;
use std::path::PathBuf;
use text_io::read;

mod actix_ructe;
mod db;
mod server;
mod short_code;

use db::DBValue;

// This includes the template code generated by ructe
include!(concat!(env!("OUT_DIR"), "/templates.rs"));

fn prompt_or_exit(msg: &str) {
    println!("{}", msg);
    let input: String = read!("{}\n");
    if input != "y" && input != "Y" {
        error!("DB not created. Exiting.");
        std::process::exit(exitcode::CANTCREAT);
    }
}

fn build_db_path(path_str: &str) -> PathBuf {
    let mut db_path = PathBuf::from(path_str);

    // append k0r.db as filename if db_path is a directory
    if db_path.is_dir() {
        db_path.push("k0r.db");
        debug!("Expanded given argument \"{}\" to {:?}", &path_str, db_path);
    }

    if !db_path.is_file() {
        let msg = format!("Database file {} not found. Create it? [y/N]", path_str);
        prompt_or_exit(&msg);
    }

    db_path
}

async fn init_db_pool(path_str: String) -> db::Pool {
    let db_path = build_db_path(&path_str);

    debug!("Initializing database...");
    let db_manager = SqliteConnectionManager::file(db_path).with_init(|c| {
        c.execute_batch(
            "
            PRAGMA journal_mode = WAL;
            PRAGMA synchronous = normal;
            PRAGMA temp_store = memory;
            PRAGMA mmap_size = 314572800;
            ",
        )
    });
    let db_pool = db::Pool::new(db_manager).unwrap();

    if (db::query(&db_pool, db::Queries::NeedsInit).await).is_err() {
        debug!("New database. Initializing schema...");
        let _ = db::query(&db_pool, db::Queries::InitDB).await;
    }

    match db::query(&db_pool, db::Queries::CountUsers).await {
        Ok(DBValue::Number(0)) => {
            match db::query(&db_pool, db::Queries::CreateUser(0, true)).await {
                Ok(DBValue::String(api_key)) => println!("Added first user with api key {}", api_key),
                Ok(v) => debug!("Got unexpected value after user creation: {:#?}", v),
                Err(err) => panic!("Failed to create super user! {}", err),
            }
        }
        Ok(DBValue::Number(_)) => { /* nothing to do */ }
        Ok(v) => debug!("Got unexpected value when counting users: {:#?}", v),
        Err(err) => panic!("Failed to create super user! {}", err),
    }

    db_pool
}

fn main() -> Result<(), std::io::Error> {
    pretty_env_logger::init();
    setup_panic!();

    let arg = std::env::args()
        .nth(1)
        .unwrap_or_else(|| String::from("./k0r.db"));

    // we don't support switches, so we treat them all like --help
    if arg.starts_with('-') {
        println!("k0r [/path/to/k0r.db]\tDatabase name defaults to ./k0r.db");
        std::process::exit(exitcode::USAGE);
    }

    let serv = async {
        let db_pool = init_db_pool(arg).await;
        debug!("Starting server...");
        server::start(db_pool)
    };

    block_on(serv)
}
