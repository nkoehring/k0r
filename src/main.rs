//! A very performant URL shortener service for individuals and small groups.
//!
//! The service builds upon the [Actix] web framework and [Rusqlite] for data
//! handling. Thanks to Actix and the speed optimized SQLite database you can
//! expect 100k requests handled per second on consumer hardware (my laptop).
//!
//! # Quick Start
//!
//! The database will be automatically initialized with a super user if it is
//! not yet existing. The api key can be found in the programs output, which
//! should look similar to the following example:
//!
//! ```sh
//! $ k0r
//! Database file k0r.db not found. Create it? [y/N]
//! y
//! Added first user with api key 859b397c-a933-461d-a9b1-86dd20084c02
//! Server is listening on 127.0.0.1:8080
//! ```
//! This will create a database file in the current directory. You can also
//! give a path instead:
//!
//! ```sh
//! $ k0r /path/to/database.db
//! ```
//!
//! For testing, you can fill the database with test URLs using the application
//! API. There is a helper script and already a file with example URLs inside
//! the `db` folder:
//!
//! ```sh
//! # assuming you're inside the project directory root and the server is running
//! ./db/insert-via-api.sh 859b397c-a933-461d-a9b1-86dd20084c02 db/test.urls
//! ```
//!
//! This inserts a bit under two-hundred URLs fetched from [250kb.club] a while
//! ago. The file contains simply one URL per line and the script is not doing
//! any checks and will throw at the API whatever it finds.
//!
//! # API Usage
//!
//! Get an URL is straight forward as expected:
//!
//! ```html
//! $ curl 127.0.0.1:8080/1
//! <!DOCTYPE html>
//! <html lang="en">
//! <head>
//!   <meta charset="UTF-8">
//!   <title>redirect â€” k0r link shortener service</title>
//!   <meta http-equiv="refresh" content="2; url=https://example.com" />
//! </head>
//! <body>You will be redirected to <a href="https://example.com">an example</a>.</body>
//! </html>
//! ```
//!
//! Inserting a URL is simple as well:
//!
//! ```sh
//! $ payload='{
//!     "url":"https://example.com",
//!     "title":"an example",
//!     "description":"totally examplary url",
//!     "key":"859b397c-a933-461d-a9b1-86dd20084c02"
//!   }'
//! $ curl -X POST localhost:8080 -H 'Content-Type: application/json' -d $payoad
//! ```
//!
//! # Planned features
//!
//! This software is still pre-alpha state and most of the planned features are
//! not yet implemented. See the [todo list] for more information about the
//! planned features and current state of implementation.
//!
//!
//! [Actix]: https://actix.rs/
//! [Rusqlite]: https://docs.rs/rusqlite/
//! [250kb.club]: https://git.sr.ht/~koehr/the-250kb-club/tree/main/item/pages.txt
//! [todo list]: https://todo.sr.ht/~koehr/k0r-planned-features
//!


#[macro_use]
extern crate log;
extern crate pretty_env_logger;
use futures::executor::block_on;
use human_panic::setup_panic;
use r2d2_sqlite::SqliteConnectionManager;
use std::path::PathBuf;
use text_io::read;

mod actix_ructe;
mod db;
mod server;
mod response_types;
mod short_code;

use db::DBValue;

// This includes the template code generated by ructe
include!(concat!(env!("OUT_DIR"), "/templates.rs"));

/// Prompts and stops process on negative response.
fn prompt_or_exit(msg: &str, err_msg: &str) {
    println!("{}", msg);
    let input: String = read!("{}\n");
    if input != "y" && input != "Y" {
        error!("{}", err_msg);
        std::process::exit(exitcode::CANTCREAT);
    }
}

/// Builds the database path with some heuristics,
/// for example /foo/ becomes /foo/k0r.db,
/// and checks for its existence. If non-existent, a prompt asks for a decision
fn build_db_path(path_str: &str) -> PathBuf {
    let mut db_path = PathBuf::from(path_str);

    // append k0r.db as filename if db_path is a directory
    if db_path.is_dir() {
        db_path.push("k0r.db");
        debug!("Expanded given argument \"{}\" to {:?}", &path_str, db_path);
    }

    if !db_path.is_file() {
        let msg = format!("Database file {} not found. Create it? [y/N]", path_str);
        prompt_or_exit(&msg, "DB not created. Exiting.");
    }

    db_path
}

/// Initializes the database connection and pool.
/// The database is configured for performance.
async fn init_db_pool(path_str: String) -> db::Pool {
    let db_path = build_db_path(&path_str);

    debug!("Initializing database...");
    let db_manager = SqliteConnectionManager::file(db_path).with_init(|c| {
        c.execute_batch(
            "
            PRAGMA journal_mode = WAL;
            PRAGMA synchronous = normal;
            PRAGMA temp_store = memory;
            PRAGMA mmap_size = 314572800;
            ",
        )
    });
    let db_pool = db::Pool::new(db_manager).unwrap();

    if (db::query(&db_pool, db::Queries::NeedsInit).await).is_err() {
        debug!("New database. Initializing schema...");
        let _ = db::query(&db_pool, db::Queries::InitDB).await;
    }

    match db::query(&db_pool, db::Queries::CountUsers).await {
        Ok(DBValue::Number(0)) => {
            match db::query(&db_pool, db::Queries::CreateUser(0, true)).await {
                Ok(DBValue::String(api_key)) => println!("Added first user with api key {}", api_key),
                Ok(v) => debug!("Got unexpected value after user creation: {:#?}", v),
                Err(err) => panic!("Failed to create super user! {}", err),
            }
        }
        Ok(DBValue::Number(_)) => { /* nothing to do */ }
        Ok(v) => debug!("Got unexpected value when counting users: {:#?}", v),
        Err(err) => panic!("Failed to create super user! {}", err),
    }

    db_pool
}

fn main() -> Result<(), std::io::Error> {
    pretty_env_logger::init();
    setup_panic!();

    let arg = std::env::args()
        .nth(1)
        .unwrap_or_else(|| String::from("./k0r.db"));

    // we don't support switches, so we treat them all like --help
    if arg.starts_with('-') {
        println!("k0r [/path/to/k0r.db]\tDatabase name defaults to ./k0r.db");
        std::process::exit(exitcode::USAGE);
    }

    let serv = async {
        let db_pool = init_db_pool(arg).await;
        debug!("Starting server...");
        server::start(db_pool)
    };

    block_on(serv)
}
